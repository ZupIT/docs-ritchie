<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ritchie – Referência</title><link>https://zupit.github.io/pt-br/refer%C3%AAncia/</link><description>Recent content in Referência on Ritchie</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://zupit.github.io/pt-br/refer%C3%AAncia/index.xml" rel="self" type="application/rss+xml"/><item><title>Referência: CLI</title><link>https://zupit.github.io/pt-br/refer%C3%AAncia/cli/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zupit.github.io/pt-br/refer%C3%AAncia/cli/</guid><description>
&lt;hr>
&lt;h2 id="introdução">Introdução&lt;/h2>
&lt;p>O CLI, ou Command Line Interface, é o &lt;strong>recurso base&lt;/strong> que permite o Ritchie funcionar. Por padrão, o CLI manipula uma pasta (a &lt;strong>pasta .rit&lt;/strong>) à medida que executa os comandos sinalizados no terminal.&lt;/p>
&lt;p>Nesta pasta, são armazenados:&lt;/p>
&lt;ul>
&lt;li>Os arquivos &lt;strong>tree.json&lt;/strong> dos repositórios de fórmulas acessíveis na máquina do usuário&lt;/li>
&lt;li>Os arquivos executáveis das &lt;strong>fórmulas&lt;/strong>&lt;/li>
&lt;li>Os arquivos &lt;strong>temporários&lt;/strong> usados no Ritchie&lt;/li>
&lt;li>Os arquivos de &lt;em>passphrase&lt;/em> e &lt;em>session&lt;/em> para a versão &lt;strong>Single&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="alert alert-info" role="alert">
Para conhecer mais sobre nosso repositório do CLI, acesse &lt;a href="https://github.com/ZupIT/ritchie-cli">&lt;strong>ritchie-cli&lt;/strong>&lt;/a> no Github.
&lt;/div>
&lt;h2 id="o-que-compõe-a-pasta-rit">O que compõe a pasta .rit?&lt;/h2>
&lt;h3 id="pasta-repo">Pasta Repo&lt;/h3>
&lt;p>A pasta &lt;strong>repo&lt;/strong> contém todos os arquivos necessários para o CLI ter conhecimento dos comandos e das fórmulas que ele pode executar.&lt;/p>
&lt;p>Ela é composta de outras pastas :&lt;/p>
&lt;ul>
&lt;li>uma pasta &lt;strong>cache&lt;/strong> que vai conter os arquivos &lt;em>tree.json&lt;/em> dos repositório de fórmulas que o usuário tem acesso (de acordo com a versão do Ritchie que estiver usando).&lt;/li>
&lt;li>uma pasta &lt;strong>local&lt;/strong> que vai conter o &lt;em>tree.json&lt;/em> do repositório onde o usuário está desenvolvendo e testando fórmulas localmente.&lt;/li>
&lt;/ul>
&lt;p>Além dessas pastas, também existe um arquivo &lt;em>&lt;strong>repositories.json&lt;/strong>&lt;/em>. Esse arquivo contém uma lista de &lt;em>tree.json&lt;/em> para o CLI identificar a quais árvores ele tem acesso, e quais são suas prioridades, a fim de evitar comandos duplicados, caso apareçam em mais de um repositório de fórmulas.&lt;/p>
&lt;h3 id="pasta-fórmulas">Pasta Fórmulas&lt;/h3>
&lt;p>A pasta &lt;strong>fórmulas&lt;/strong> contém todos os arquivos necessários para o CLI realizar a execução das fórmulas.&lt;/p>
&lt;p>Ela é composta de várias pastas, uma por fórmula, contendo o executável da fórmula de acordo com o sistema operacional usado, assim que o &lt;em>config.json&lt;/em> associado para identificar os parâmetros de entrada necessários para a fórmula ser executada corretamente.&lt;/p>
&lt;p>Esses arquivos são baixados, e essas pastas são criadas quando o CLI executa o comando de uma fórmula pela &lt;a href="https://docs.ritchiecli.io/v/doc-portuguese/principais-conceitos#formulas">primeira vez&lt;/a> (são buscados através do &lt;em>repoUrl&lt;/em> da fórmula informado no &lt;em>tree.json&lt;/em> associado).&lt;/p>
&lt;p>Quando o usuário testa uma fórmula que ele desenvolveu localmente, o arquivo &lt;em>Makefile&lt;/em> contido no repositório de fórmulas usado adicionará os executáveis da fórmula dentro dessa pasta, criando a mesma estrutura que seria criada caso a fórmula fosse baixada de um servidor.&lt;/p>
&lt;h3 id="pasta-tmp">Pasta tmp&lt;/h3>
&lt;p>A pasta &lt;strong>tmp&lt;/strong> é onde estão armazenados os arquivos temporários que podem ser criados ou manipulados durante a execução de algumas fórmulas ou comandos cores. Esses arquivos temporários podem ser templates, certificados, ou outros arquivos do tipo com uso único.&lt;/p>
&lt;h3 id="passphrase--session">Passphrase &amp;amp; Session&lt;/h3>
&lt;p>Os arquivos &lt;strong>passphrase&lt;/strong> &amp;amp; &lt;strong>session&lt;/strong> são arquivos criptografados usados na versão &lt;strong>Single&lt;/strong> para conseguir definir dados que serão usados de forma repetitivas no Ritchie. Esses dados podem ser &lt;em>credenciais&lt;/em> de algumas ferramentas manipuladas nas fórmulas, ou até a definição do &lt;em>contexto&lt;/em> usado para realizar algumas automações.&lt;/p></description></item><item><title>Referência: Fórmulas</title><link>https://zupit.github.io/pt-br/refer%C3%AAncia/f%C3%B3rmulas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zupit.github.io/pt-br/refer%C3%AAncia/f%C3%B3rmulas/</guid><description>
&lt;hr>
&lt;h2 id="introdução">Introdução&lt;/h2>
&lt;p>As fórmulas são, no contexto do Ritchie, as automações a serem executadas para que você realize uma ação em menos tempo e com mais eficiência.&lt;/p>
&lt;div class="alert alert-info" role="alert">
Para conhecer mais fórmulas disponíveis no Ritchie, acesse o repositório &lt;a href="https://github.com/ZupIT/ritchie-formulas">&lt;strong>ritchie-formulas&lt;/strong>&lt;/a> no Github.
&lt;/div>
&lt;h2 id="repositório-de-fórmulas">Repositório de fórmulas&lt;/h2>
&lt;p>As fórmulas são armazenadas em &lt;strong>repositórios de fórmulas&lt;/strong>, que precisam ter uma estrutura particular.&lt;/p>
&lt;p>Cada repositório deve conter os seguintes elementos:&lt;/p>
&lt;ul>
&lt;li>As pastas das fórmulas.&lt;/li>
&lt;li>Uma pasta tree&lt;/li>
&lt;li>Um arquivo Makefile&lt;/li>
&lt;li>Um arquivo copy-bin-configs.sh&lt;/li>
&lt;li>Um arquivo unzip-bin-configs.sh&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://zupit.github.io/screenshot-2020-05-22-at-17.27.48%20%281%29.png" alt="Reposit&amp;#xF3;rio de f&amp;#xF3;rmulas da comunidade">&lt;/p>
&lt;p>Cada &lt;strong>pasta de fórmula&lt;/strong> vai conter o código executável e os arquivos referentes a uma fórmula.&lt;/p>
&lt;p>A pasta &lt;strong>tree&lt;/strong> é composta de um arquivo &lt;em>&lt;strong>tree.json&lt;/strong>&lt;/em> que vai conter a árvore dos comandos de todas as fórmulas do repositório.&lt;/p>
&lt;p>O arquivo &lt;em>&lt;strong>Makefile&lt;/strong>&lt;/em> contem uma referência a todas as fórmulas do repositório, assim que um comando executável manipulando os arquivos &lt;strong>copy-bin-configs.sh&lt;/strong> e &lt;strong>unzip-bin-configs.sh,&lt;/strong> a fim de gerar os arquivos necessários para testar as fórmula(s) localmente na &lt;a href="https://docs.ritchiecli.io/v/doc-portuguese/referencia/cli#o-que-compoe-a-pasta-rit">pasta .rit&lt;/a>.&lt;/p>
&lt;h3 id="composição-de-fórmulas">Composição de fórmulas&lt;/h3>
&lt;div class="alert alert-info" role="alert">
Cada fórmula é composta de vários arquivos permitindo sua execução pelo CLI.
&lt;/div>
&lt;p>Para uma fórmula ser executada pelo terminal, é preciso ter:&lt;/p>
&lt;ul>
&lt;li>Um arquivo tree.json do repositório onde está a fórmula configurada.&lt;/li>
&lt;li>Um arquivo executável&lt;/li>
&lt;li>Um arquivo config.json&lt;/li>
&lt;/ul>
&lt;p>O &lt;strong>tree.json&lt;/strong> permite que o CLI reconheça os comandos e sub-comandos associados a fórmula. É assim que ele identifica onde baixar os arquivos da fórmula na primeira execução (sob demanda).&lt;/p>
&lt;p>O &lt;strong>arquivo executável&lt;/strong> contém a implementação da fórmula. O CLI vai baixar esse arquivo de acordo com o sistema operacional do computador do usuário e executar essa fórmula enviando os parâmetros de entrada que terão sido informados.&lt;/p>
&lt;p>O arquivo &lt;strong>config.json&lt;/strong> contém os parâmetros de entrada (&lt;em>inputs&lt;/em>) da fórmula. Ele que permite que o CLI saiba quais informações ele precisará pedir para o usuário quando ele executará o comando no terminal a fim de processar a fórmula corretamente.&lt;/p>
&lt;h4 id="configjson">Config.json&lt;/h4>
&lt;p>Esse arquivo contém as seguintes informações :&lt;/p>
&lt;ul>
&lt;li>uma descrição&lt;/li>
&lt;li>os parâmetros de entrada da fórmula&lt;/li>
&lt;/ul>
&lt;p>Esses parâmetros de entrada são compostos dos seguintes campos:&lt;/p>
&lt;ul>
&lt;li>nome&lt;/li>
&lt;li>tipo&lt;/li>
&lt;li>label&lt;/li>
&lt;li>default (facultativo)&lt;/li>
&lt;li>items (facultativo)&lt;/li>
&lt;li>cache (facultativo)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">{
&amp;#34;description&amp;#34;: &amp;#34;Sample inputs in Ritchie.&amp;#34;,
&amp;#34;inputs&amp;#34; : [
{
&amp;#34;name&amp;#34; : &amp;#34;sample_text&amp;#34;,
&amp;#34;type&amp;#34; : &amp;#34;text&amp;#34;,
&amp;#34;label&amp;#34; : &amp;#34;Type : &amp;#34;,
&amp;#34;cache&amp;#34; : {
&amp;#34;active&amp;#34;: true,
&amp;#34;qtd&amp;#34; : 6,
&amp;#34;newLabel&amp;#34; : &amp;#34;Type new value. &amp;#34;
}
},
{
&amp;#34;name&amp;#34; : &amp;#34;sample_list&amp;#34;,
&amp;#34;type&amp;#34; : &amp;#34;text&amp;#34;,
&amp;#34;default&amp;#34; : &amp;#34;in1&amp;#34;,
&amp;#34;items&amp;#34; : [&amp;#34;in_list1&amp;#34;, &amp;#34;in_list2&amp;#34;, &amp;#34;in_list3&amp;#34;, &amp;#34;in_listN&amp;#34;],
&amp;#34;label&amp;#34; : &amp;#34;Pick your : &amp;#34;
},
{
&amp;#34;name&amp;#34; : &amp;#34;sample_bool&amp;#34;,
&amp;#34;type&amp;#34; : &amp;#34;bool&amp;#34;,
&amp;#34;default&amp;#34; : &amp;#34;false&amp;#34;,
&amp;#34;items&amp;#34; : [&amp;#34;false&amp;#34;, &amp;#34;true&amp;#34;],
&amp;#34;label&amp;#34; : &amp;#34;Pick: &amp;#34;
}
]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>O campo &lt;strong>nome&lt;/strong> se refere ao nome da variável que será extraído na implementação da fórmula.&lt;/p>
&lt;p>O campo &lt;strong>tipo&lt;/strong> representa o tipo da variável (no momento só existe &lt;strong>TEXT&lt;/strong> e &lt;strong>BOOL&lt;/strong>)&lt;/p>
&lt;p>O campo &lt;strong>label&lt;/strong> é o texto que vai aparecer para o usuário via PROMPT para informar essa variável.&lt;/p>
&lt;p>O campo &lt;strong>default&lt;/strong> é o valor da variável que virá por padrão caso a escolha seja uma lista de opões.&lt;/p>
&lt;p>O campo &lt;strong>items&lt;/strong> é a lista de opções possíveis para a variável.&lt;/p>
&lt;p>O campo &lt;strong>cache&lt;/strong> permite configurar se será necessário armazenar as escolhas do usuário para essa variável. Ele é composto de 3 campos :&lt;/p>
&lt;ul>
&lt;li>active&lt;/li>
&lt;li>qtd&lt;/li>
&lt;li>newLabel.&lt;/li>
&lt;/ul>
&lt;p>O campo &lt;strong>active&lt;/strong> indica se o cache está habilitado ou não.&lt;/p>
&lt;p>O campo &lt;strong>qtd&lt;/strong> se refere a quantidade de escolhas que podem ser armazenadas no cache.&lt;/p>
&lt;p>O campo &lt;strong>newLabel&lt;/strong> é para o usuário informar um outro valor para a variável caso aquelas salvas no cache não atendem sua necessidade.&lt;/p>
&lt;h3 id="treejson">Tree.json&lt;/h3>
&lt;div class="alert alert-info" role="alert">
&lt;p>&lt;strong>Cada&lt;/strong> repositório de fórmulas do Ritchie tem uma &lt;strong>árvore de comando.&lt;/strong>&lt;/p>
&lt;p>Essa árvore de comando é configurada num arquivo chamado &lt;em>&lt;strong>tree.json.&lt;/strong>&lt;/em>&lt;/p>
&lt;/div>
&lt;p>É através desse(s) JSON que o CLI vai conseguir localizar os comandos que ele tem acesso, e as informações necessárias para encontrar os executáveis das fórmulas.&lt;/p>
&lt;p>A estrutura de um tree.json é a seguinte:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">{
&amp;#34;commands&amp;#34;: [
{
&amp;#34;usage&amp;#34;: &amp;#34;aws&amp;#34;,
&amp;#34;help&amp;#34;: &amp;#34;Apply Aws objects&amp;#34;,
&amp;#34;parent&amp;#34;: &amp;#34;root&amp;#34;
},
{
&amp;#34;usage&amp;#34;: &amp;#34;apply&amp;#34;,
&amp;#34;help&amp;#34;: &amp;#34;Apply Aws objects&amp;#34;,
&amp;#34;parent&amp;#34;: &amp;#34;root_aws&amp;#34;
},
{
&amp;#34;usage&amp;#34;: &amp;#34;terraform&amp;#34;,
&amp;#34;help&amp;#34;: &amp;#34;Apply Aws terraform objects&amp;#34;,
&amp;#34;formula&amp;#34;: {
&amp;#34;path&amp;#34;: &amp;#34;aws/terraform&amp;#34;,
&amp;#34;bin&amp;#34;: &amp;#34;terraform-cli-${so}&amp;#34;,
&amp;#34;bundle&amp;#34;: &amp;#34;${so}.zip&amp;#34;,
&amp;#34;repoUrl&amp;#34;: &amp;#34;https://commons-repo.ritchiecli.io/formulas&amp;#34;
},
&amp;#34;parent&amp;#34;: &amp;#34;root_aws_apply&amp;#34;
}
]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Vamos seguir com o exemplo do comando &lt;strong>&lt;code>RIT AWS APPLY TERRAFORM&lt;/code>&lt;/strong>&lt;/p>
&lt;p>Cada comando contido nessa lista pode conter até 4 parâmetros:&lt;/p>
&lt;ul>
&lt;li>usage&lt;/li>
&lt;li>help&lt;/li>
&lt;li>parent&lt;/li>
&lt;li>formula&lt;/li>
&lt;/ul>
&lt;p>O campo &lt;strong>usage&lt;/strong> se refere a palavra usada no comando (&lt;strong>aws&lt;/strong>, &lt;strong>apply&lt;/strong> e &lt;strong>terraforma&lt;/strong> no exemplo).&lt;/p>
&lt;p>O campo &lt;strong>help&lt;/strong> representa a mensagem de ajuda que aparecerá ao usuário caso ele digite esse comando.&lt;/p>
&lt;p>O campo &lt;strong>parent&lt;/strong> indica os comandos anteriores na árvore, usando eventualmente um underline ( _ ) para separar os comandos. ROOT sendo uma palavra reservada fazendo referência ao comando RIT.&lt;/p>
&lt;p>Quando um comando contém apenas esses 3 campos (&lt;strong>usage, help, parent&lt;/strong>) significa que ele não é executável, e que ele faz apenas parte de um conjunto de comandos que juntos executarão uma fórmula.&lt;/p>
&lt;p>O campo &lt;strong>formula&lt;/strong> vai conter as informações necessárias para o CLI identificar onde buscar os executáveis necessários para executar a fórmula. Ele é composto de 3 campos :&lt;/p>
&lt;ul>
&lt;li>repoUrl&lt;/li>
&lt;li>path&lt;/li>
&lt;li>bin&lt;/li>
&lt;/ul>
&lt;p>O campo &lt;strong>repoUrl&lt;/strong> se refere ao endereço onde estão localizados os arquivos executáveis da fórmula.&lt;/p>
&lt;div class="alert alert-warning" role="alert">
É importante anotar que o Ritchie não baixa todas as fórmulas na sua instalação. O CLI só baixa os executáveis das fórmulas &lt;em>on demands&lt;/em>, ou seja, quando ele executa os comandos das fórmulas pela primeira vez.
&lt;/div>
&lt;p>O campo &lt;strong>path&lt;/strong> indica a pasta que será criada localmente no computador do usuário para adicionar esses arquivos executáveis.&lt;/p>
&lt;p>O campo &lt;strong>bin&lt;/strong> informa qual é o nome do arquivo executável que o CLI deverá baixar, de acordo com o sistema operacional (SO) da máquina do usuário.&lt;/p>
&lt;p>Executando os comandos da fórmula da AWS acima, existem os seguintes cenários :&lt;/p>
&lt;ul>
&lt;li>&lt;code>rit aws&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">Apply Aws objects
Available Commands:
apply Apply Aws objects
Use &amp;#34;rit &amp;lt;command&amp;gt; --help&amp;#34; for more information about a given command.
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>rit aws apply&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">Apply Aws objects
Available Commands:
terraform Apply Aws terraform objects
Use &amp;#34;rit &amp;lt;command&amp;gt; --help&amp;#34; for more information about a given command.
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>rit aws apply terraform&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">Downloading config file...
Done.
Download formula...
Done.
Installing formula...
Directory Created: /Users/Dennis/.rit/formulas/aws/terraform/bin
File extracted: bin/terraform-cli-darwin
Done.
Use the arrow keys to navigate: ↓ ↑ → ←
Select your repository URL:
▸ https://github.com/zupit/iti-stack-core
https://github.com/zupit/iti-stack-tools
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Os primeiros comandos (&lt;strong>&lt;code>rit aws&lt;/code>&lt;/strong> e &lt;strong>&lt;code>rit aws apply&lt;/code>&lt;/strong>) retornaram o campo &lt;strong>help&lt;/strong> associado ao comando no &lt;em>tree.json&lt;/em>, assim que os sub-comandos disponíveis para o usuário conseguir executar uma fórmula.&lt;/p>
&lt;p>Já, o comando &lt;strong>&lt;code>rit aws apply terraform&lt;/code>&lt;/strong> baixou os executáveis da fórmula e começou a pedir os parâmetros de entrada ao usuário.&lt;/p>
&lt;h3 id="makefile-e-shell-scripts">Makefile e Shell Scripts&lt;/h3>
&lt;p>Esses 3 arquivos abaixo são usados para gerar arquivos localmente no .rit folder, isso é feito quando o usuário precisa testar a automação do código que ele tenha implementado.&lt;/p>
&lt;ul>
&lt;li>Makefile&lt;/li>
&lt;li>copy-bin-configs.sh&lt;/li>
&lt;li>unzip-bin-configs.sh&lt;/li>
&lt;/ul>
&lt;p>Quando uma nova fórmula é criada, o caminho onde ela está localizada no repositório precisa ser informado no &lt;strong>Makefile&lt;/strong> do root do repositório, como no exemplo a seguir:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">#Makefiles
SC_SPRING_STARTER=scaffold/spring-starter
KAFKA=kafka
DOCKER=docker/compose
FORMULAS=$(SC_SPRING_STARTER) $(KAFKA) $(DOCKER)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Nesse arquivo também se encontra o comando &lt;code>test-local&lt;/code> que permite o usuário gerar arquivos executáveis de uma ou mais fórmulas e colocá-los temporariamente dentro da pasta Ritchie (.rit) localizado no home da máquina do usuário.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">test-local:
ifneq (&amp;#34;$(FORM)&amp;#34;, &amp;#34;&amp;#34;)
@echo &amp;#34;Using form true: &amp;#34; $(FORM_TO_UPPER)
$(MAKE) bin FORMULAS=$(FORM)
mkdir -p $(HOME)/.rit/formulas
rm -rf $(HOME)/.rit/formulas/$(FORM)
./unzip-bin-configs.sh
cp -r formulas/* $(HOME)/.rit/formulas
rm -rf formulas
else
@echo &amp;#34;Use make test-local form=NAME_FORMULA for specific formula.&amp;#34;
@echo &amp;#34;form false: ALL FORMULAS&amp;#34;
$(MAKE) bin
rm -rf $(HOME)/.rit/formulas
./unzip-bin-configs.sh
mv formulas $(HOME)/.rit
endif
mkdir -p $(HOME)/.rit/repo/local
rm -rf $(HOME)/.rit/repo/local/tree.json
cp tree/tree.json $(HOME)/.rit/repo/local/tree.json
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Os arquivos &lt;strong>copy-bin-configs.sh&lt;/strong> e &lt;strong>unzip-bin-configs.sh&lt;/strong> são manipulados pelo comando &lt;strong>test-local&lt;/strong> para extrair os arquivos executáveis e o &lt;strong>config.json&lt;/strong> das fórmulas escolhidas e movê-las para a pasta .rit.&lt;/p>
&lt;p>&lt;strong>Há duas formas de usar o comando Makefile:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Informando a fórmula específica para testar de acordo com o nome colocado no Makefile:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">make test-local form={nome_formula}
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>Executando diretamente o script de &lt;strong>test-local&lt;/strong> para adicionar todas as fórmulas do repositório para a pasta temporária .rit:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">make test-local
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Depois de adicionar a formula no .rit por meio do Makefile (main), será possível executar o comando associado com aquela fórmula por meio do terminal (conclusão automática não funcionará nesse caso).&lt;/p>
&lt;h3 id="compilação--teste-de-fórmulas">&lt;strong>Compilação / teste de fórmulas&lt;/strong>&lt;/h3>
&lt;p>Conforme explicado no &lt;a href="https://docs.ritchiecli.io/v/doc-portuguese/casos-de-uso/criando-formulas#passo-4-testar-a-nova-implementacao-da-formula">passo 4 da seção de criação de fórmula&lt;/a>, é possível gerar arquivos executáveis de uma fórmula para teste com o comando rit build formula.&lt;/p>
&lt;p>Mas o que acontece exatamente ao executar este comando? Bem, está tudo relacionado ao arquivo Makefile do repositório na raiz do repositório.&lt;/p>
&lt;p>Ao criar a nova fórmula, o caminho em que a fórmula está localizada no repositório foi adicionado automaticamente ao arquivo &lt;strong>Makefile&lt;/strong> do repositório.&lt;/p>
&lt;p>Portanto, a execução do comando rit build formula corresponde à execução do comando &lt;strong>&lt;code>make test-local form = {formula_name}&lt;/code>&lt;/strong> do arquivo &lt;strong>Makefile&lt;/strong> do repositório.&lt;/p>
&lt;p>&lt;img src="https://lh4.googleusercontent.com/8hoDs7Km57x5E8SBCVZsHGpv4rhTmU7UNoGae9xuxjIKWtKwlrvKPLH1S8DLX1WpDrYE8LPyI7KcxT1hl8oy6pSoUu2cb2r0CuwjFWHJztvBLtmUzUAN_hHwEcexbD0kOhyHgcou" alt="Compila&amp;#xE7;&amp;#xE3;o de uma f&amp;#xF3;rmula">&lt;/p>
&lt;h2 id="acesso-às-fórmulas">Acesso às fórmulas&lt;/h2>
&lt;div class="alert alert-info" role="alert">
Todos os &lt;strong>comandos acessíveis pelo CLI&lt;/strong> podem ser observados através do &lt;em>Helper&lt;/em>
&lt;/div>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">➜ rit --help
A CLI that developers can build and operate
your applications without help from the infra staff.
Complete documentation is available at https://github.com/ZupIT/ritchie-cli
core commands:
add add objects
completion Add autocomplete for terminal
clean clean objects
create Create objects
delete Delete objects
list list objects
set Set objects
show Show objects
update update objects
commons commands:
aws Apply Aws objects
docker Manipulate docker objects
github Manipulate GitHub objects
k8s Manipulate k8s objects
kafka Kafka commands
scaffold Manipulate scaffold objects
Other Commands:
Options:
-v, --version: version for rit
Usage:
rit [flags] [options]
Use &amp;#34;rit &amp;lt;command&amp;gt; --help&amp;#34; for more information about a given command.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Quando um usuário vai baixar o Ritchie (&lt;a href="https://docs.ritchiecli.io/v/doc-portuguese/primeiros-passos/escolhendo-versao#versao-single">versão Single&lt;/a>) ou efetuar o comando &lt;strong>rit login&lt;/strong> (&lt;a href="https://docs.ritchiecli.io/v/doc-portuguese/primeiros-passos/escolhendo-versao#versao-team">versão Team&lt;/a>) para acessar o repositório de uma organização, o &lt;strong>CLI&lt;/strong> vai baixar e realizar o merge dos &lt;em>tree.json&lt;/em> dos repositórios de fórmulas aos quais o usuário tem acesso.&lt;/p>
&lt;p>&lt;img src="https://zupit.github.io/fluxo-cli.png" alt="">&lt;/p>
&lt;p>A junção das árvores dos repositórios será a árvore de todos os comandos disponíveis via o CLI no computador do usuário, que é apresentada no &lt;em>Helper&lt;/em>.&lt;/p>
&lt;h2 id="prioridade-entre-repositórios">Prioridade entre repositórios&lt;/h2>
&lt;div class="alert alert-info" role="alert">
&lt;p>Existe um conceito de &lt;strong>prioridade&lt;/strong> entre as árvores de comando dos &lt;strong>repositórios de fórmulas.&lt;/strong>&lt;/p>
&lt;p>Isso permite &lt;strong>evitar&lt;/strong> &lt;strong>comandos&lt;/strong> &lt;strong>repetitivos&lt;/strong> após a junção das árvores de todos os comandos pelo CLI.&lt;/p>
&lt;/div>
&lt;p>Segue a prioridade padrão definida no CLI entre os repositórios :&lt;/p>
&lt;ul>
&lt;li>Prioridade 0: Core&lt;/li>
&lt;li>Prioridade 1: Local&lt;/li>
&lt;li>Prioridade 2: Outros repositórios&lt;/li>
&lt;/ul>
&lt;p>Essa regra permite que cada usuário (single) / empresa (team) defina a prioridade entre os demais repositórios.&lt;/p>
&lt;h3 id="exemplos-de-prioridade">&lt;strong>Exemplos de prioridade&lt;/strong>&lt;/h3>
&lt;p>É possível um usuário escolher entre os 2 cenários abaixo :&lt;/p>
&lt;p>&lt;img src="https://lh4.googleusercontent.com/XwM1MIenWGVB45DjC1A7-t_glfsYaznphkJMe7Bcxaa6RJpmy9pRBVW9hNaNw_LFJO5iEl4Zx9uNGAgpxLkPa6awswyeb_D7JktkN6M-Wntc0ad5e26LHE4I3PjoQe3Wnh29JpES" alt="">&lt;img src="https://lh5.googleusercontent.com/h-6piqq1Yl-T7veYMe5rrlVWGi22P4RMs0Y3vcYn-sITSkW2w2SCXR9NjPq0jgcRwWpZnCTmIoO7jXJgc4hm9-3y1Q9SKyQwl75PtTSow4IIEoZ53Tx71FIkNIl6QsNHOrn_nUca" alt="">&lt;/p>
&lt;h4 id="cenário-1">&lt;strong>Cenário 1&lt;/strong>&lt;/h4>
&lt;p>Seria dado prioridade aos comandos &lt;strong>commons&lt;/strong> sobre os comandos do seu &lt;strong>time&lt;/strong>.&lt;/p>
&lt;h4 id="cenário-2">&lt;strong>Cenário 2&lt;/strong>&lt;/h4>
&lt;p>Seria dado prioridade aos comandos do repositório do &lt;strong>time&lt;/strong> sobre os comandos &lt;strong>commons&lt;/strong>.&lt;/p>
&lt;p>Isso permitiria por exemplo a um usuário, ou time, de usar um comando que está na árvore do repositório do &lt;strong>ritchie-formulas&lt;/strong> para uma fórmulas no repositório dele, realizando uma operação diferente com o mesmo comando, já que teria prioridade.&lt;/p>
&lt;div class="alert alert-warning" role="alert">
&lt;p>É possível configurar a prioridade entre os repositórios na pasta &lt;strong>repo&lt;/strong> da &lt;a href="https://docs.ritchiecli.io/v/doc-portuguese/referencia/cli#o-que-compoe-a-pasta-rit">pasta .rit&lt;/a> onde tem um arquivo &lt;strong>repositories.json&lt;/strong> configurável.&lt;/p>
&lt;p>Por mais informações sobre como manipular repositórios, confere a documentação aqui: &lt;a href="https://docs.ritchiecli.io/v/doc-portuguese/primeiros-comandos/repositorio">Repositório&lt;/a>.&lt;/p>
&lt;/div></description></item><item><title>Referência: Servidor</title><link>https://zupit.github.io/pt-br/refer%C3%AAncia/servidor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zupit.github.io/pt-br/refer%C3%AAncia/servidor/</guid><description>
&lt;hr>
&lt;h2 id="introdução">Introdução&lt;/h2>
&lt;p>Presente apenas na Versão Team, o servidor no Ritchie é o responsável por fornecer as informações que o CLI precisa para executar os comandos.&lt;/p>
&lt;p>Para que isso aconteça, cada time precisa ter um arquivo de configuração para iniciar o seu servidor quando usar o Ritchie. Este arquivo é o &lt;strong>file_config.json&lt;/strong>.&lt;/p>
&lt;p>Além do arquivo de configuração, o CLI também providencia as informações que precisa por meio do &lt;strong>repositório ritchie-server.&lt;/strong>&lt;/p>
&lt;div class="alert alert-info" role="alert">
Para conhecer o repositório do servidor, acesse &lt;a href="https://github.com/ZupIT/ritchie-server">&lt;strong>ritchie-server&lt;/strong>&lt;/a> no Github.
&lt;/div>
&lt;h2 id="configurar-o-servidor">Configurar o servidor&lt;/h2>
&lt;p>O arquivo &lt;strong>file_config.json&lt;/strong> vai conter a parte de configuração e de autorização aos trees e comandos, isso envolve os seguintes campos:&lt;/p>
&lt;ul>
&lt;li>tenant/time&lt;/li>
&lt;li>keycloak&lt;/li>
&lt;li>cliVersionPath&lt;/li>
&lt;li>repositories&lt;/li>
&lt;li>oauth&lt;/li>
&lt;li>credentials&lt;/li>
&lt;/ul>
&lt;p>O &lt;strong>tenant/time&lt;/strong> representa o nome da organização que deverá ser informada pelo usuário na hora de fazer o login com o Ritchie na versão Team.&lt;/p>
&lt;p>O campo &lt;em>&lt;strong>keycloak&lt;/strong>&lt;/em> se refere as configurações do client &lt;a href="https://www.keycloak.org/">Keycloak&lt;/a> utilizado pelo server para validar o token e gerenciar o keycloak (url, realm, clientId e clientSecret)&lt;/p>
&lt;p>O campo &lt;em>&lt;strong>cliVersionPath&lt;/strong>&lt;/em> informa a URL para o provider afim de identificar a versão do CLI sendo usada.&lt;/p>
&lt;p>O campo &lt;em>&lt;strong>repositories&lt;/strong>&lt;/em> indica as configurações dos repositórios de fórmulas acessíveis pelo time (com nome, prioridade, treePath, urls) que o CLI vai usar para baixar os tree.json que ficarão na &lt;a href="https://docs.ritchiecli.io/v/doc-portuguese/referencia/cli#o-que-compoe-a-pasta-rit">pasta .rit&lt;/a>&lt;/p>
&lt;p>O campo &lt;em>&lt;strong>oauth&lt;/strong>&lt;/em> contém a URL que será usada para realizar o login via a ferramenta SSO (Single Sign On) usada pelo time.&lt;/p>
&lt;p>O campo &lt;em>&lt;strong>credentials&lt;/strong>&lt;/em> contém uma lista das credenciais que podem ser usadas dentro do ambiente da organização, que podem ser definidas tanto pelos usuários, quanto pelos administradores do servidor (para usuários específicos, ou para o time inteiro) através do comando &lt;strong>&lt;code>rit set credential&lt;/code>&lt;/strong>.&lt;/p>
&lt;h3 id="exemplo-de-um-file_configjson">Exemplo de um &lt;strong>file_config.json&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">{
&amp;#34;zup&amp;#34;: {
&amp;#34;keycloak&amp;#34;: {
&amp;#34;url&amp;#34;: &amp;#34;http://localhost:8080&amp;#34;,
&amp;#34;realm&amp;#34;: &amp;#34;ritchie&amp;#34;,
&amp;#34;clientId&amp;#34;: &amp;#34;user-login&amp;#34;,
&amp;#34;clientSecret&amp;#34;: &amp;#34;user-login&amp;#34;
},
&amp;#34;cliVersionPath&amp;#34;: {
&amp;#34;provider&amp;#34;: &amp;#34;s3&amp;#34;,
&amp;#34;url&amp;#34;: &amp;#34;http://localhost:8882/s3-version-mock&amp;#34;
},
&amp;#34;repositories&amp;#34;:
[
{
&amp;#34;name&amp;#34;: &amp;#34;commons&amp;#34;,
&amp;#34;priority&amp;#34;: 0,
&amp;#34;treePath&amp;#34;: &amp;#34;/tree/tree.json&amp;#34;,
&amp;#34;remote&amp;#34; : &amp;#34;http://localhost:8882&amp;#34;,
&amp;#34;serverUrl&amp;#34; : &amp;#34;http://localhost:3000&amp;#34;,
&amp;#34;replaceRepoUrl&amp;#34; : &amp;#34;http://localhost:3000/formulas&amp;#34;
},
{
&amp;#34;name&amp;#34;: &amp;#34;zup&amp;#34;,
&amp;#34;priority&amp;#34;: 1,
&amp;#34;treePath&amp;#34;: &amp;#34;/tree/tree-zup.json&amp;#34;,
&amp;#34;remote&amp;#34; : &amp;#34;http://localhost:8882&amp;#34;,
&amp;#34;serverUrl&amp;#34; : &amp;#34;http://localhost:3000&amp;#34;,
&amp;#34;replaceRepoUrl&amp;#34; : &amp;#34;http://localhost:3000/formulas&amp;#34;
}
],
&amp;#34;oauth&amp;#34; :{
&amp;#34;url&amp;#34; : &amp;#34;http://localhost:8080/auth/realms/ritchie&amp;#34;,
&amp;#34;clientId&amp;#34; : &amp;#34;oauth&amp;#34;
},
&amp;#34;credentials&amp;#34;: {
&amp;#34;github&amp;#34;: [
{
&amp;#34;field&amp;#34;: &amp;#34;username&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;text&amp;#34;
},
{
&amp;#34;field&amp;#34;: &amp;#34;token&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;password&amp;#34;
}
],
&amp;#34;gitlab&amp;#34;: [
{
&amp;#34;field&amp;#34;: &amp;#34;username&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;text&amp;#34;
},
{
&amp;#34;field&amp;#34;: &amp;#34;token&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;password&amp;#34;
}
],
&amp;#34;email-zup&amp;#34;: [
{
&amp;#34;field&amp;#34;: &amp;#34;email&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;text&amp;#34;
},
{
&amp;#34;field&amp;#34;: &amp;#34;token&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;password&amp;#34;
}
]
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="testar-o-servidor">Testar o servidor&lt;/h2>
&lt;p>Para a versão &lt;strong>Team&lt;/strong> funcionar no CLI, a organização vai precisar ter :&lt;/p>
&lt;ul>
&lt;li>um servidor&lt;/li>
&lt;li>uma conta no &lt;a href="https://www.keycloak.org/">Keycloak&lt;/a> (ferramenta open source)&lt;/li>
&lt;li>uma conta no &lt;a href="https://www.vaultproject.io/">Vault&lt;/a> (ferramenta open source)&lt;/li>
&lt;/ul>
&lt;p>É possível testar essas configurações &lt;strong>localmente&lt;/strong>, observando através de arquivos do Postman (disponibilizados na pasta &lt;strong>/testdata&lt;/strong>) como os endpoints do servidor são manipulados pelo CLI para funcionar.&lt;/p>
&lt;div class="alert alert-warning" role="alert">
Para realizar esse teste, será necessário clonar o &lt;a href="https://github.com/ZupIT/ritchie-server">repositório do ritchie-server&lt;/a> no computador.
&lt;/div>
&lt;p>Para iniciar esse teste é preciso subir o &lt;strong>docker-compose&lt;/strong> na raíz do produto : &lt;code>$ docker-compose up&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">version: &amp;#39;3&amp;#39;
services:
vault:
image: vault:1.3.0
ports:
- &amp;#34;8200:8200&amp;#34;
volumes:
- ./resources/vault.hcl:/vault/config/vault.hcl
environment:
- VAULT_DEV_ROOT_TOKEN_ID=87e7784b-d598-44fe-8962-c7c345a11eed
- VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200
- SKIP_SETCAP=true
- disable_mlock=true
keycloak:
image: jboss/keycloak:7.0.0
environment:
DB_VENDOR: H2
KEYCLOAK_IMPORT: /tmp/keycloak/ritchie.json
KEYCLOAK_USER: admin
KEYCLOAK_PASSWORD: admin
ports:
- &amp;#34;8080:8080&amp;#34;
volumes:
- ./testdata/security/keycloak:/tmp/keycloak
stubby4j:
image: sandokandias/stubby4j-docker
ports:
- &amp;#34;8787:8787&amp;#34;
- &amp;#34;8882:8882&amp;#34;
environment:
STUBBY_PORT: 8882
volumes:
- ./testdata/stubby4j/integrations.yml:/usr/local/stubby.yml
- ./testdata/stubby4j/response.zip:/usr/local/response.zip
&lt;/code>&lt;/pre>&lt;/div>&lt;p>E depois executar o arquivo &lt;strong>run-local.sh&lt;/strong> : &lt;code>$ sh run-local.sh&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">#!/bin/bash
./create-vault-approle.sh . http://0.0.0.0:8200
export VAULT_ADDR=http://localhost:8200
export VAULT_AUTHENTICATION=APPROLE
export VAULT_ROLE_ID=$(cat /tmp/vault/role-id.txt)
export VAULT_SECRET_ID=$(cat /tmp/vault/secret-id.txt)
export FILE_CONFIG=&amp;#34;$(pwd)/server/resources/file_config_local.json&amp;#34;
go run server//server/main.go
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esses 2 arquivos funcionam em conjunto com o &lt;strong>file_config-local.json&lt;/strong> localizado na pasta &lt;strong>/server/resources&lt;/strong> do repositório do ritchie-server.&lt;/p>
&lt;p>Uma que tudo estiver subido será possível executar as requisições via Postman que o CLI envia para o servidor para buscar as informações necessárias ao seu funcionamento.&lt;/p>
&lt;div class="alert alert-warning" role="alert">
Um &lt;strong>comando core&lt;/strong> está sendo desenvolvido para permitir que um time consiga criar os arquivos de configurações assim que o realm no kubectl, para conseguir gerar um servidor já funcionando com o Ritchie de forma simplificada.
&lt;/div>
&lt;h2 id="configurações-de-credenciais">Configurações de credenciais&lt;/h2>
&lt;p>O comando &lt;strong>&lt;code>rit set credential&lt;/code>&lt;/strong> permitir salvar credenciais na sessão (localmente na versão Single, no Vault na versão Team) para o usuário aproveitar esses dados sem precisar informá-los novamente ao executar suas fórmulas.&lt;/p>
&lt;p>Para usar essas credenciais como inputs numa fórmula, existe uma palavra chave que precisa ser informado no arquivo config.json da fórmula.&lt;/p>
&lt;div class="alert alert-warning" role="alert">
&lt;p>Esse arquivo é onde são configurados os parâmetros de entrada que serão pedidos ao usuário quando ele executará o comando no terminal para processar a fórmula.&lt;/p>
&lt;p>Essa palavra-chave é &lt;strong>CREDENTIAL.&lt;/strong>&lt;/p>
&lt;/div>
&lt;p>Para saber como usá-la, é preciso ter acesso ao repositório do &lt;code>ritchie-server&lt;/code>, e observar como as credenciais de cada ferramenta são registrada no arquivo &lt;code>resources/file_config_local.json&lt;/code>&lt;/p>
&lt;p>Por exemplo, as &lt;strong>credenciais do Github&lt;/strong> são configuradas da seguinte forma :&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">&amp;#34;credentials&amp;#34;: {
&amp;#34;github&amp;#34;: [
{
&amp;#34;field&amp;#34;: &amp;#34;username&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;text&amp;#34;
},
{
&amp;#34;field&amp;#34;: &amp;#34;token&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;password&amp;#34;
}
]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Consequentemente, para conseguir usar as credenciais do Github como input no &lt;code>config.json&lt;/code> de uma fórmula, precisaria informar eles da seguinte forma :&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">&amp;#34;inputs&amp;#34;: [
{
&amp;#34;name&amp;#34;: &amp;#34;git_user&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;CREDENTIAL_GITHUB_USERNAME&amp;#34;
},
{
&amp;#34;name&amp;#34;: &amp;#34;git_token&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;CREDENTIAL_GITHUB_TOKEN&amp;#34;
}
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Assim, quando o comando da fórmula será executado, as credenciais do Github serão buscadas diretamente na sessão, e poderão ser usadas na fórmulas sem o usuário informar-las novamente no terminal.&lt;/p>
&lt;div class="alert alert-warning" role="alert">
Lembrando que para isso funcionar, é preciso o usuário ter efetuado o login (rit login), e ter setado as credenciais referentes a ferramenta (rit set credential).
&lt;/div></description></item><item><title>Referência: Releases</title><link>https://zupit.github.io/pt-br/refer%C3%AAncia/releases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zupit.github.io/pt-br/refer%C3%AAncia/releases/</guid><description/></item><item><title>Referência: Roadmap</title><link>https://zupit.github.io/pt-br/refer%C3%AAncia/roadmap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zupit.github.io/pt-br/refer%C3%AAncia/roadmap/</guid><description/></item></channel></rss>